/*Вершина графа u
 называется инцидентной ребру e
, если u
 является одним из концов ребра e
.

Аналогично, ребро e
 называется инцидентным вершине u
, если один из концов e
 — это вершина u
.

Матрицей инцидентности графа G=(V,E)
 называется прямоугольная таблица из |V|
 строк и |E|
 столбцов, в которой на пересечении i
-й строки и j
-го столбца записана единица, если вершина i
 инцидентна ребру j
, и ноль в противном случае.

Дан неориентированный граф. Выведите его матрицу инцидентности.

Входные данные
В первой строке входного файла заданы числа N
 и M
 через пробел — количество вершин и рёбер в графе, соответственно (1⩽N⩽100
, 0⩽M⩽10000
). Следующие M
 строк содержат по два числа ui
 и vi
 через пробел (1⩽ui,vi⩽N
); каждая такая строка означает, что в графе существует ребро между вершинами ui
 и vi
. Рёбра нумеруются в том порядке, в котором они даны во входном файле, начиная с единицы.

Выходные данные
Выведите в выходной файл N
 строк, по M
 чисел в каждой. j
-й элемент i
-й строки должен быть равен единице, если вершина i
 инцидентна ребру j
, и нулю в противном случае. Разделяйте соседние элементы строки одним пробелом.

*/

#include <iostream>
#include <vector>

int main() {

    int verticesAmount;
    int edgesAmount;
    std::cin >> verticesAmount >> edgesAmount;
    std::vector<int> table(verticesAmount * edgesAmount, 0);
    int startVertex;
    int endVertex;

    for (int i = 0; i < edgesAmount; ++i) {

        std::cin >> startVertex >> endVertex;
        startVertex--;
        endVertex--;
        table[edgesAmount * startVertex + i] = 1;
        table[edgesAmount * endVertex + i] = 1;

    }

    for (int i = 0; i < verticesAmount; ++i) {
        for (int j = 0; j < edgesAmount; ++j) {
            std::cout << table[edgesAmount * i + j] << ' ';
        }
        std::cout << '\n';
    }

}
